# REQ : Stardog running: 1. on port  5820
#       2. with --disable-security option during start
# SRC :
# NOTE:
# TODO: Adjust code for use in a new version of CollapsibeTree-Shiny.R to use
#       paths instead of SPARQL.
###############################################################################
library(SPARQL)
library(collapsibleTree)
# Query StardogTriple Store ----
endpoint <- "http://localhost:5820/seq/query"
queryOnt = paste0("
PREFIX eg: <http://www.example.org/myproject#>
PATHS START ?s = eg:Thing1
END ?o
VIA ?p
")
qd <- SPARQL(endpoint, queryOnt)
triplesDF <- qd$results
View(triplesDF)
View(triplesDF)
# Post query processing
triplesDF <- triplesDF[complete.cases(triplesDF), ]  # remove blank rows.
triplesDF <- triplesDF[, c("s", "p", "o")]   # remove o.l, s.l
###############################################################################
# FILE: Stardog-PathQuery.R
# DESC: Developing the Stardog path query functionality for later use in
#         RShiny app.
# SRC :
# IN  : triplestore database CTDasRDFOnt
# OUT :
# REQ : Stardog running: 1. on port  5820
#       2. with --disable-security option during start
# SRC :
# NOTE:
# TODO: Adjust code for use in a new version of CollapsibeTree-Shiny.R to use
#       paths instead of SPARQL.
###############################################################################
library(SPARQL)
library(collapsibleTree)
# Query StardogTriple Store ----
endpoint <- "http://localhost:5820/seq/query"
queryOnt = paste0("
PREFIX eg: <http://www.example.org/myproject#>
PATHS START ?s = eg:Thing1
END ?o
VIA ?p
")
qd <- SPARQL(endpoint, queryOnt)
triplesDF <- qd$results
# Post query processing
triplesDF <- triplesDF[complete.cases(triplesDF), ]  # remove blank rows.
triplesDF <- triplesDF[, c("s", "p", "o")]   # remove o.l, s.l
triplesDF <- unique(triplesDF)  # Remove dupes
###############################################################################
# FILE: Stardog-PathQuery.R
# DESC: Developing the Stardog path query functionality for later use in
#         RShiny app.
# SRC :
# IN  : triplestore database CTDasRDFOnt
# OUT :
# REQ : Stardog running: 1. on port  5820
#       2. with --disable-security option during start
# SRC :
# NOTE:
# TODO: Adjust code for use in a new version of CollapsibeTree-Shiny.R to use
#       paths instead of SPARQL.
###############################################################################
library(SPARQL)
library(collapsibleTree)
# Query StardogTriple Store ----
endpoint <- "http://localhost:5820/seq/query"
queryOnt = paste0("
PREFIX eg: <http://www.example.org/myproject#>
PATHS START ?s = eg:Thing1
END ?o
VIA ?p
")
qd <- SPARQL(endpoint, queryOnt)
triplesDF <- qd$results
# Post query processing
triplesDF <- triplesDF[complete.cases(triplesDF), ]  # remove blank rows.
triplesDF <- triplesDF[, c("s", "p", "o")]   # remove o.l, s.l
triplesDF <- unique(triplesDF)  # Remove dupes
source('C:/_sandbox/SemanticWeb/UCB/MacroTracker/RBM/data/TTL/Stardog-PathQuery.R', echo=TRUE)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
###############################################################################
# FILE: Stardog-PathQuery.R
# DESC: Developing the Stardog path query functionality for later use in
#         RShiny app.
# SRC :
# IN  : triplestore database CTDasRDFOnt
# OUT :
# REQ : Stardog running: 1. on port  5820
#       2. with --disable-security option during start
# SRC :
# NOTE:
# TODO: Adjust code for use in a new version of CollapsibeTree-Shiny.R to use
#       paths instead of SPARQL.
###############################################################################
library(SPARQL)
library(collapsibleTree)
# Query StardogTriple Store ----
endpoint <- "http://localhost:5820/seq/query"
#queryOnt = paste0("
#  PREFIX eg: <http://www.example.org/myproject#>
#  PATHS START ?s = eg:Thing1
#  END ?o
#  VIA ?p
#")
queryOnt = paste0("
PREFIX eg: <http://www.example.org/myproject#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
paths start ?s = eg:Thing1
end ?o { ?o rdf:type ?oType } via eg:andThen
")
qd <- SPARQL(endpoint, queryOnt)
triplesDF <- qd$results
View(triplesDF)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
source('C:/_sandbox/Applications/stardog/SPARQL/Stardog-PathQuery.R', echo=TRUE)
library(utils)
foo <-"Hispanic or Latino"
foo
foo2 <- URLencode(foo)
foo2 <- URLencode(foo)
foo2
library(utils)
foo <-"Hispanic or Latino"
en_foo <- URLencode(foo)
en_foo
source('C:/_gitHub/CTDasRDF/r/DM_imputeCSV.R', echo=TRUE)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
# ** Impute ----
#---- Birthdate : asbsent in source data
# NOTE: Date calculations based on SECONDS so you must convert the age in Years to seconds
#      Change to character to avoid later ddply problem in DM_process.R
#      Dates reflect their original mixed format of DATE or DATETIME in same col.
dm$brthdate <- as.character(strptime(strptime(dm$rfstdtc, "%Y-%m-%d") - (strtoi(dm$age) * 365.25 * 24 * 60 * 60), "%Y-%m-%d"))
#---- Informed Consent  (column present with missing values in DM source).
dm$rficdtc <- dm$dmdtc   # Confirm this is not in the new Test Data factory version.
# Death Date and Flag set for Person 1 for testing purposes only.
#   Will not match original source data! (no deaths)
# Unfactorize the dthdtc column to allow entry of a bogus date
dm$dthdtc <- as.character(dm$dthdtc)
dm$dthdtc[dm$usubjid == '01-701-1015' ] <- "2013-12-26"  # Death Date
dm$dthfl[dm$usubjid == '01-701-1015' ]  <- "Y" # Set a Death flag  for Person_1
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name
dm$en_age      <- URLencode(dm$age)
dm$en_brthdate <- URLencode(dm$brthdate)
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name
dm$en_age      <- URLencode(toString(dm$age))
dm$en_brthdate <- URLencode(dm$brthdate)
dm$en_dmdtc    <- URLencode(dm$dmdtc)
dm$en_dthdtc   <- URLencode(dm$brthdate)
dm$en_ethnic   <- URLencode(dm$ethnic)
dm$en_race     <- URLencode(dm$race)
dm$en_ethnic   <- URLencode(dm$ethnic)
dm$en_ethnic   <- URLencode(toString(dm$ethnic))
dm$en_race     <- URLencode(dm$race)
dm$en_race     <- URLencode(toString(dm$race))
dm$en_rfendtc  <- URLencode(dm$rfstdtc)
dm$en_rficdtc  <- URLencode(dm$rficdtc)
dm$en_rfpendtc <- URLencode(dm$rfpendtc)
dm$en_rfstdtc  <- URLencode(dm$rfstdtc)
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name.
#   Fucntion will be called by the various xx_imputCSV.R scripts.
dm$en_age      <- URLencode(toString(dm$age))
dm$en_brthdate <- URLencode(dm$brthdate)
dm$en_dmdtc    <- URLencode(dm$dmdtc)
dm$en_dthdtc   <- URLencode(dm$brthdate)
dm$en_ethnic   <- URLencode(toString(dm$ethnic))
dm$en_race     <- URLencode(toString(dm$race))
dm$en_rfendtc  <- URLencode(dm$rfstdtc)
dm$en_rficdtc  <- URLencode(dm$rficdtc)
dm$en_rfpendtc <- URLencode(dm$rfpendtc)
dm$en_rfstdtc  <- URLencode(dm$rfstdtc)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
View(dm)
View(dm)
# ** Impute ----
#---- Birthdate : asbsent in source data
# NOTE: Date calculations based on SECONDS so you must convert the age in Years to seconds
#      Change to character to avoid later ddply problem in DM_process.R
#      Dates reflect their original mixed format of DATE or DATETIME in same col.
dm$brthdate <- as.character(strptime(strptime(dm$rfstdtc, "%Y-%m-%d") - (strtoi(dm$age) * 365.25 * 24 * 60 * 60), "%Y-%m-%d"))
#---- Informed Consent  (column present with missing values in DM source).
dm$rficdtc <- dm$dmdtc   # Confirm this is not in the new Test Data factory version.
# FILE: XPTtoCSV.R
# DESC: Convert XPT domain file to CSV
# SRC :
# IN  :
# OUT :
# REQ :
# SRC :
# NOTE: Some imputed values to match ontology development requirements.
# TODO:
###############################################################################
library(Hmisc)
library(car)   # recode
library(utils)
dm_n=3;  # The first n patients from the DM domain.
# Subsetting to allow incremental dev
pntSubset<-c('01-701-1015') # List of usubjid's to process.
# Set working directory to the root of the work area
setwd("C:/_github/CTDasRDF")
readXPT<-function(domain)
{
sourceFile <- paste0("data/source/", domain, ".XPT")
result <- sasxport.get(sourceFile)
result  # return the dataframe
}
# ---- XPT Import -------------------------------------------------------------
# DM ----
dm  <- head(readXPT("dm"), dm_n)
# Impute values needed for testing
source('R/DM_imputeCSV.R')  # Creates birthdate.
View(dm)
?URLencode
install.packages("RCurl")
trace(utils:::unpackPkgZip, edit=TRUE)
install.packages("RCurl")
library(RCurl)
library(RCurl)
dm$foo <- curlEscape(dm$age)
dm$foo
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name.
#   Fucntion will be called by the various xx_imputCSV.R scripts.
dm$en_age      <- URLencode(toString(dm$age))
dm$en_age
dm$en_brthdate <- curlEscape(dm$brthdate)
dm$brthdate_en <- curlEscape(dm$brthdate)
#dm$en_dmdtc    <- URLencode(dm$dmdtc)
#dm$en_dthdtc   <- URLencode(dm$dthdtc)
#dm$en_ethnic   <- URLencode(toString(dm$ethnic))
dm$race_en     <- curlEscape(dm$race)
#dm$en_dmdtc    <- URLencode(dm$dmdtc)
#dm$en_dthdtc   <- URLencode(dm$dthdtc)
dm$ethnic_en   <- curlEscape(dm$ethnic)
# -----------------------------------------------------------------------------
# DESC: Create df column values dynamically based on function parameter values
# SRC :
# IN  :
# OUT :
# REQ :
# NOTE:  use of !! and :=
#        Used in CTDasRDF project
# TODO:
###############################################################################
library(plyr)
library(dplyr)
library(RCurl)
testDf <- read.table(header=T, text='
age     ethnic
65      Hispanic or Latino
57      Hawaian or Pacfic
')
testDf <- read.table(header=T, text='
age     ethnic
65      "Hispanic or Latino"
57      "Hawaian or Pacfic"
')
View(testDf)
View(testDf)
encodeVar<-function(domainName, sourceCol)
{
varname <- paste0(dataCol, "_en")
domainName %>%
mutate( !!varname := curlEscape(varname))
}
encodeVar(domainName=testDf, sourceCol="age")
encodeVar<-function(domainName, sourceCol)
{
varname <- paste0(sourceCol, "_en")
domainName %>%
mutate( !!varname := curlEscape(varname))
}
encodeVar(domainName=testDf, sourceCol="age")
encodeVar<-function(domainName, sourceCol)
{
varname <- paste0(sourceCol, "_en")
domainName %>%
mutate( !!varname := curlEscape(sourceCol))
}
encodeVar(domainName=testDf, sourceCol="age")
encodeVar<-function(domainName, sourceCol)
{
varname <- paste0(sourceCol, "_en")
domainName %>%
mutate( !!varname := curlEscape(!!sourceCol))
}
encodeVar(domainName=testDf, sourceCol="age")
encodeVar<-function(domainName, sourceCol)
{
varname <- paste0(sourceCol, "_en")
domainName %>%
mutate( !!varname := curlEscape([[sourceCol]]))
}
testDf <- read.table(header=T, text='
age     ethnic
65      "Hispanic or Latino"
57      "Hawaian or Pacfic"
')
encodeVar<-function(data, col)
{
encoded <- paste0(col, "_en")
data %>%
mutate( !!encoded := curlEscape(data[,col]))
}
encodeVar(data=testDf, col="age")
###############################################################################
# FILE: XPTtoCSV.R
# DESC: Convert XPT domain file to CSV
# SRC :
# IN  :
# OUT :
# REQ :
# SRC :
# NOTE: Some imputed values to match ontology development requirements.
# TODO:
###############################################################################
library(Hmisc)
library(car)   # recode
library(utils)  # for URLencode - no longer used. DELETE
library(RCurl)  # to encode URL values
dm_n=3;  # The first n patients from the DM domain.
# Subsetting to allow incremental dev
pntSubset<-c('01-701-1015') # List of usubjid's to process.
# Set working directory to the root of the work area
setwd("C:/_github/CTDasRDF")
source('R/Functions.R')  # Functions: readXPT(), encodeCol(), etc.
#______________________________________________________________________________
# FILE: DM_imputeCSV.R
# DESC: Creates data values required for prototyping and ontoloty develeopment
# REQ : Prior import of the DM domain by driver script.
# SRC : N/A
# IN  : dm dataframe
# OUT : modified dm dataframe
# NOTE: Columns that created that are not usually in SDTM are prefixed with im_
#       Eg: im_lifespan  - for lifespan IRI creation
#           im_sdtmterm  - to link to SDTM terminlology
#           brthdate  - no im_ prefix because this is often collected in SDTM.
# TODO:
#______________________________________________________________________________
# ** Impute ----
#---- Birthdate : asbsent in source data
# NOTE: Date calculations based on SECONDS so you must convert the age in Years to seconds
#      Change to character to avoid later ddply problem in DM_process.R
#      Dates reflect their original mixed format of DATE or DATETIME in same col.
dm$brthdate <- as.character(strptime(strptime(dm$rfstdtc, "%Y-%m-%d") - (strtoi(dm$age) * 365.25 * 24 * 60 * 60), "%Y-%m-%d"))
#---- Informed Consent  (column present with missing values in DM source).
dm$rficdtc <- dm$dmdtc   # Confirm this is not in the new Test Data factory version.
# Death Date and Flag set for Person 1 for testing purposes only.
#   Will not match original source data! (no deaths)
# Unfactorize the dthdtc column to allow entry of a bogus date
dm$dthdtc <- as.character(dm$dthdtc)
dm$dthdtc[dm$usubjid == '01-701-1015' ] <- "2013-12-26"  # Death Date
dm$dthfl[dm$usubjid == '01-701-1015' ]  <- "Y" # Set a Death flag  for Person_1
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name.
#   Fucntion will be called by the various xx_imputCSV.R scripts.
# ---- XPT Import -------------------------------------------------------------
# DM ----
dm  <- head(readXPT("dm"), dm_n)
source('R/Functions.R')  # Functions: readXPT(), encodeCol(), etc.
# ---- XPT Import -------------------------------------------------------------
# DM ----
dm  <- head(readXPT("dm"), dm_n)
###############################################################################
# FILE: XPTtoCSV.R
# DESC: Convert XPT domain file to CSV
# SRC :
# IN  :
# OUT :
# REQ :
# SRC :
# NOTE: Some imputed values to match ontology development requirements.
# TODO:
###############################################################################
library(Hmisc)
library(car)   # recode
library(utils)  # for URLencode - no longer used. DELETE
library(RCurl)  # to encode URL values
dm_n=3;  # The first n patients from the DM domain.
# Subsetting to allow incremental dev
pntSubset<-c('01-701-1015') # List of usubjid's to process.
# Set working directory to the root of the work area
setwd("C:/_github/CTDasRDF")
source('R/Functions.R')  # Functions: readXPT(), encodeCol(), etc.
# ---- XPT Import -------------------------------------------------------------
# DM ----
dm  <- head(readXPT("dm"), dm_n)
#______________________________________________________________________________
# FILE: DM_imputeCSV.R
# DESC: Creates data values required for prototyping and ontoloty develeopment
# REQ : Prior import of the DM domain by driver script.
# SRC : N/A
# IN  : dm dataframe
# OUT : modified dm dataframe
# NOTE: Columns that created that are not usually in SDTM are prefixed with im_
#       Eg: im_lifespan  - for lifespan IRI creation
#           im_sdtmterm  - to link to SDTM terminlology
#           brthdate  - no im_ prefix because this is often collected in SDTM.
# TODO:
#______________________________________________________________________________
# ** Impute ----
#---- Birthdate : asbsent in source data
# NOTE: Date calculations based on SECONDS so you must convert the age in Years to seconds
#      Change to character to avoid later ddply problem in DM_process.R
#      Dates reflect their original mixed format of DATE or DATETIME in same col.
dm$brthdate <- as.character(strptime(strptime(dm$rfstdtc, "%Y-%m-%d") - (strtoi(dm$age) * 365.25 * 24 * 60 * 60), "%Y-%m-%d"))
#---- Informed Consent  (column present with missing values in DM source).
dm$rficdtc <- dm$dmdtc   # Confirm this is not in the new Test Data factory version.
# Death Date and Flag set for Person 1 for testing purposes only.
#   Will not match original source data! (no deaths)
# Unfactorize the dthdtc column to allow entry of a bogus date
dm$dthdtc <- as.character(dm$dthdtc)
dm$dthdtc[dm$usubjid == '01-701-1015' ] <- "2013-12-26"  # Death Date
dm$dthfl[dm$usubjid == '01-701-1015' ]  <- "Y" # Set a Death flag  for Person_1
encodeCol(data=dm, col=age)
View(dm)
View(dm)
encodeCol(data=dm, col="age")
View(dm)
encodeCol(data=dm, col="ethnic")
dm<-encodeCol(data=dm, col="ethnic")
View(dm)
###############################################################################
# FILE: XPTtoCSV.R
# DESC: Convert XPT domain file to CSV
# SRC :
# IN  :
# OUT :
# REQ :
# SRC :
# NOTE: Some imputed values to match ontology development requirements.
# TODO:
###############################################################################
library(Hmisc)
library(car)   # recode
library(utils)  # for URLencode - no longer used. DELETE
library(RCurl)  # to encode URL values
dm_n=3;  # The first n patients from the DM domain.
# Subsetting to allow incremental dev
pntSubset<-c('01-701-1015') # List of usubjid's to process.
# Set working directory to the root of the work area
setwd("C:/_github/CTDasRDF")
source('R/Functions.R')  # Functions: readXPT(), encodeCol(), etc.
# ---- XPT Import -------------------------------------------------------------
# DM ----
dm  <- head(readXPT("dm"), dm_n)
#______________________________________________________________________________
# FILE: DM_imputeCSV.R
# DESC: Creates data values required for prototyping and ontoloty develeopment
# REQ : Prior import of the DM domain by driver script.
# SRC : N/A
# IN  : dm dataframe
# OUT : modified dm dataframe
# NOTE: Columns that created that are not usually in SDTM are prefixed with im_
#       Eg: im_lifespan  - for lifespan IRI creation
#           im_sdtmterm  - to link to SDTM terminlology
#           brthdate  - no im_ prefix because this is often collected in SDTM.
# TODO:
#______________________________________________________________________________
# ** Impute ----
#---- Birthdate : asbsent in source data
# NOTE: Date calculations based on SECONDS so you must convert the age in Years to seconds
#      Change to character to avoid later ddply problem in DM_process.R
#      Dates reflect their original mixed format of DATE or DATETIME in same col.
dm$brthdate <- as.character(strptime(strptime(dm$rfstdtc, "%Y-%m-%d") - (strtoi(dm$age) * 365.25 * 24 * 60 * 60), "%Y-%m-%d"))
#---- Informed Consent  (column present with missing values in DM source).
dm$rficdtc <- dm$dmdtc   # Confirm this is not in the new Test Data factory version.
# Death Date and Flag set for Person 1 for testing purposes only.
#   Will not match original source data! (no deaths)
# Unfactorize the dthdtc column to allow entry of a bogus date
dm$dthdtc <- as.character(dm$dthdtc)
dm$dthdtc[dm$usubjid == '01-701-1015' ] <- "2013-12-26"  # Death Date
dm$dthfl[dm$usubjid == '01-701-1015' ]  <- "Y" # Set a Death flag  for Person_1
#------------------------------------------------------------------------------
# URL encoding
#   Encode fields  that may potentially have values that violate valid IRI format
# TODO: Create function that creates encoded version into new var name.
#   Fucntion will be called by the various xx_imputCSV.R scripts.
encodeCol(data=dm, col="age")
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
View(dm)
View(dm)
# Sort column names in the df for quicker referencing
dm <- dm %>% select(noquote(order(colnames(dm))))
View(dm)
View(dm)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R', echo=TRUE)
