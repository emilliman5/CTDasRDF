library(shiny); runApp('CompTriples-Stardog-Shiny.R')
# SRC : Based on code fullTriplesComp.R from comparing TTL file.
# IN  : Hard coded input files to save time during QC
# OUT : datatable
# REQ : rrdf
# NOTE: Side by side display of the triples available from Ont,R, not just the ones
#         that do not match.
# TODO: Add "exceptions" dataframe to remove artifacts from either source in the
#        in the comparison.
#       Convert to use of redland pkg
###############################################################################
library(plyr)    #  rename
library(dplyr)   # anti_join. MUst load dplyr AFTER plyr!!
library(reshape) #  melt
library(SPARQL)
library(DT)
setwd("C:/_gitHub/CTDasRDF/r")
source("validation/Functions.R")
# Endpoints
epOnt = "http://localhost:5820/CTDasRDFOnt/query"
epSMS = "http://localhost:5820/CTDasRDF/query"
# Read in the prefixes
prefixList <- read.csv(file="prefixList.csv", header=TRUE, sep=",")
# Create a combined prefix IRI column.
prefixList$prefix_ <- paste0("PREFIX ",prefixList$prefix, " ", prefixList$iri)
# Collapse into a single string
prefixBlock <- paste(prefixList$prefix_, collapse = "\n")
# All s,p,o from both files.
query = paste0(paste(prefixes$prefixDef, collapse=""),
"SELECT ?s ?p ?o
WHERE {?s ?p ?o .}
ORDER BY ?s ?p ?o")
# All s,p,o from both files.
query = paste0(paste(prefixesBlock, collapse=""),
"SELECT ?s ?p ?o
WHERE {?s ?p ?o .}
ORDER BY ?s ?p ?o")
# All s,p,o from both files.
query = paste0(paste(prefixeBlock, collapse=""),
"SELECT ?s ?p ?o
WHERE {?s ?p ?o .}
ORDER BY ?s ?p ?o")
# All s,p,o from both files.
query = paste0(paste(prefixBlock, collapse=""),
"SELECT ?s ?p ?o
WHERE {?s ?p ?o .}
ORDER BY ?s ?p ?o")
#---- Ontology Triples---------------------------------------------------------
qrOnt <- SPARQL(url=epOnt, query=query)
triplesOnt <- qrOnt$results
# Shorten from IRI to qnam
triplesOnt <- IRItoPrefix(sourceDF=triplesOnt, colsToParse=c("s", "p", "o"))
# Sort the dataframe values for display
triplesOnt<-triplesOnt[with(triplesOnt, order(p, o)), ]
# Remove cases where O is missing in the Ontology source(atrifact from TopBraid)
triplesOnt <-triplesOnt[!(triplesOnt$o==""),]
triplesOnt <- triplesOnt[complete.cases(triplesOnt), ]
#---- SMS Triples ---------------------------------------------------------------
qrSMS <- SPARQL(url=epSMS, query=query)
triplesSMS <- qrSMS$results
# Shorten from IRI to qnam
triplesSMS <- IRItoPrefix(sourceDF=triplesSMS, colsToParse=c("s", "p", "o"))
#--- In R and not in Ontology
SMSNotOnt <-anti_join(triplesSMS, triplesOnt)
SMSNotOnt <-RNotOnt[with(SMSNotOnt, order(s,p,o)), ]  # Not needed...
SMSNotOnt <-SMSNotOnt[with(SMSNotOnt, order(s,p,o)), ]  # Not needed...
OntNotSMS <- anti_join(triplesOnt, triplesSMS)
OntNotSMS <- OntNotSMS[with(OntNotSMS, order(s,p,o)), ]  # Not needed...
datatable(OntNotSMS)
source('C:/_gitHub/CTDasRDF/r/XPTtoCSV.R')
