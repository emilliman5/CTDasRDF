<!DOCTYPE html>
<!-----------------------------------------------------------------------------
FILE: DataRelations-FNGraph.html
DSCR: Network graph of Data Relations in the SDTM Data as RDF Project
SRC :   Based on: (svn) /Phuse/Anual/2016/d3/Attendees-FNGraph.html
INPUT:  /data/DataRelations-FNGraph-test.JSON  - for development
        /data/Attendees-FNGraph-R.JSON , from R,   [TODO!!!]
VIEW  :  http://localhost:8000/SDTMasRDF/vis/d3/NameSpaceRelations-FNGraph.html
REQ  : DataRelations-FNGraph.js, SDTMasRDF.css
NOTES: 
TODO: : Create the R code based on the original from the Annual conference, but with
        Data from this project.

------------------------------------------------------------------------------>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SDTMasRDF Namespace Relations</title>
    <script type="text/javascript" src="/SDTMasRDF/vis/d3/d3/d3.v3.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/SDTMasRDF/vis/d3/SDTMasRDF.css">
</head>
<body>
<h3>SDTM Data as RDF: Namespace Relations</h3>
<script type="text/javascript">
var w = 1300;  
var h = 900;  

// Factors affecting node display (spread, clustering, etc.)
// Note: Colours set in .CSS
var gravity  = .01
var charge   = -240
linkDistance = 80
edgeWidth    = 3

var color = d3.scale.ordinal()
              .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
              .range([ "#FFFFFF", // 1-Wht     Default/ Cube Structure
                       "#00FF00", // 2-BrGre   Atributes
                       "#99FF99", // 3-LtGre   Atribute link
                       "#FF0000", // 4-BrRed   Measure
                       "#FA7D7D", // 5-LtRed   Measure link
                       "#0000FF", // 6-BrBlu   Dimension
                       "#8080FF", // 7-LtBlu   Dimension link
                       "#FF6600", // 8-BrOr    CodeLists
                       "#FFB280", // 9-LtOr    CodeLists link
                       "#CC00FF", // 10-BrPur  CDISC
                       "#EB99FF", // 11-LtPur  CDISC link
                       "#FFFF00", // 12-BrYel  Observations
                       "#FFFF80", // 13-LtYel  Observations link
                       "#006666", // 14-SlGre   Cube Struct
                       "#99C2C2", // 15-LtSlGre Cube Struct Link
                       "#666699", // 16-BlGry  SKOS
                       "#A3A3C2"  // 17-LtBlGr SKOS Link
                       ]);

//Width and height for SVG area
var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h)
            //.attr("viewBox", "0 0 2500 2500")
            .style("background-color", '#002b36');


  // Double click to 'unfix' the node and have forces start to act on it again.
  function dblclick(d) {
    d3.select(this).classed("fixed", d.fixed = false);
  }
  // Set the "fixed" property of the dragged node to TRUE when a dragstart event is initiated,
  //   - removes "forces" from acting on that node and changing its position.
  function dragstart(d) {
    d3.select(this).classed("fixed", d.fixed = true);
  }

//---- LEGEND  ----------------------------------------------------------------
var nodeTypes = ["CODE", "STUDY", "TIME"];

var nodeRadius = 5  // Size of nodes. Later make this a caculation based on number of nodes in display?
// Variables for clustering 
var nb_group=3 // divide display into  n regions, 1 for nodeCategory value
var angle = 2*Math.PI/nb_group; // Angle to divide up the display
var intensity = 200; // increase intensity if many groups

// node size scale
var nodeScale = d3.scale.linear()
    .domain([0,180])
    .range([3,20]);

// Indent from left margin
var legendIndent=20;

// Title 
svg.append("text")
     .text("Legend")
     .attr("x",legendIndent+20)
     .attr("y",25)
     .attr("class", 'legendTitle'); 

// Box to surround the legend
svg.append("rect")
     .attr("x",legendIndent-15)
     .attr("y",35)
     .attr("rx", 2) // Round the edge
     .attr("ry", 2) // Round the edge
     .attr("height", 192)
     .attr("width", 145)
     .attr("class", "legendBox");

var legend = svg.selectAll(".legend")
    .data(nodeTypes)
    .enter()
    .append("g")
    .attr("class", "legend");

legend.append("circle") 
    .attr("cx", legendIndent ) // legendIndent+n = to move in from legend box left edge
       // first val is spacing between each rect
       // +n = spacing down from top of legend box
    .attr("cy",function(d, i) { return 32 * i +50; })
    .attr("r", 8)
    .attr("class", function (d, i) {
            return nodeTypes[i];
        })
    .style("fill-opacity", 0.9);
     
legend.append("text")
  .attr("class", "monoLG")
  .text(function(d, i) { 
  	 return nodeTypes[i];
  })
  .attr("x", legendIndent + 15)  // +n = spacing in from left edge of legend box
  .attr("y", function(d, i) { return (32 * i) +55; }); // 32* = spacing, +nn to center on node
//---- LEGEND END -------------------------------------------------------------

// d3.json("/SDTMasRDF/vis/d3/data/DataRelations-FNGraph-test.JSON", function(dataset) {
 d3.json("/SDTMasRDF/vis/d3/data/NamespaceRelations-FROMR.JSON", function(dataset) {
// d3.json("/SDTMasRDF/vis/d3/data/DataRelations-FNGraph-R.JSON", function(dataset) {
    var force = d3.layout.force()
        .nodes(dataset.nodes)
        .links(dataset.edges)
        .gravity(gravity) 
        .charge(charge)
        .linkDistance(linkDistance)
        .size([w, h])
        .start();
    var drag = force.drag()
        .on("dragstart", dragstart);

    // id value - used to identify the edge. Where is it referenced?
    var edges = svg.selectAll("line")
        .data(dataset.edges)
        .enter()
        .append("line")
        .attr("id",function(d,i){return 'edge'+i})
        .attr("stroke-width", edgeWidth)
        .attr("class", function (d) {
            return d.edgeType;
        });
    // Add tooltip mouseover text for Edges (links) 
    edges.append("title")
        .text(function(d) { return d.value });
         
   var nodes = svg.selectAll("g.node")
        .data(dataset.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .on("dblclick", dblclick)
        .on("click", function (d) {
          if (d3.event.ctrlKey) { location.href = d.url;}
        })
        .call(drag);

    nodes.append("circle")
        // .attr("r", function(d) { return nodeScale(d.freq); 
        .attr("r", nodeRadius)
        .attr("class", function (d) {
            return d.type;
        })
        // Mousover Node - highlight node by fading the node colour during mouseover
        .on('mouseover', function(d){
            var nodeSelection = d3.select(this).style({opacity:'0.5'});
        })
        //Mouseout Node  - bring node back to full colour   
        .on('mouseout', function(d){
            var nodeSelection= d3.select(this).style({opacity:'1.0',}) 
        })
    // dx sets how close to the node the label appears
    //TW TODO: Move font size and color to CSS STYLE
   // id=nodegroup3  - a separate style for this node type. See #nodegroup3 in CSS section
    nodes.append("text")
        .attr("class", "nodetext")
        .attr("dx",function(d){ 
            if (d.id == 0) {return ""} 
            else {return -15;}
        ;})// offset the text from the node. 
        .attr("dy", "-1.5em") // Offset label fromnode. Move above node with -
        .attr("text-anchor", "middle")  // Center text horizontally
        .text(function(d) { return d.label })            // Just the name

    // Egdge Paths
    //TODO remove stroke and path: are part of CSS now
    var edgepaths = svg.selectAll(".edgepath")
        .data(dataset.edges)
        .enter()
        .append('path')
        .attr({'d': function(d) {return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},
            'class':'edgepath',
            'fill-opacity':0,
            'stroke-opacity':0,
            
            'id':function(d,i) {return 'edgepath'+i}})
        .style("pointer-events", "none");

    force.on("tick", function(e) {
    	  // Position regulator for nodes must update d.x and d.y BEFORE edges are positioned
        nodes.attr("transform", function(d) { 
            d.x += (intensity*Math.cos(angle*(d.nodeCategory)) + w/2 - d.x)*e.alpha;
            d.y += (intensity*Math.sin(angle*(d.nodeCategory)) + h/2 - d.y)*e.alpha;
            return "translate(" + d.x + "," + d.y + ")"; 
        });
        edges.attr("x1", function(d) { return d.source.x; })
            .attr("y1",  function(d) { return d.source.y; })
            .attr("x2",  function(d) { return d.target.x; })
            .attr("y2",  function(d) { return d.target.y; });
      
        edgepaths.attr('d', function(d) { var path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;
            //console.log(d)
            return path});       

      });     
  });  // end of data read and manip
</script>
</body>
</html>